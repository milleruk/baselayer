{% load static %}

<!-- Interactive Workout Player -->
{% if chart_data and chart_data.zones %}
<div class="workout-player-section">
  <!-- Workout Header -->
  <div class="workout-header">
    <div class="workout-info">
      <p class="workout-instructor-label">Instructor name: <span class="workout-instructor-name">{% if ride.instructor %}{{ ride.instructor.name }}{% elif ride.instructor_name %}{{ ride.instructor_name }}{% else %}N/A{% endif %}</span></p>
      <p class="workout-output">Pace Target</p>
    </div>
    <div class="workout-controls">
      <div class="pace-level-control">
        <label for="pace-level-select">Pace Level:</label>
        <select id="pace-level-select" class="pace-level-select">
          <option value="1" {% if user_pace_level == 1 %}selected{% endif %}>Level 1</option>
          <option value="2" {% if user_pace_level == 2 %}selected{% endif %}>Level 2</option>
          <option value="3" {% if user_pace_level == 3 %}selected{% endif %}>Level 3</option>
          <option value="4" {% if user_pace_level == 4 %}selected{% endif %}>Level 4</option>
          <option value="5" {% if user_pace_level == 5 or not user_pace_level %}selected{% endif %}>Level 5</option>
          <option value="6" {% if user_pace_level == 6 %}selected{% endif %}>Level 6</option>
          <option value="7" {% if user_pace_level == 7 %}selected{% endif %}>Level 7</option>
          <option value="8" {% if user_pace_level == 8 %}selected{% endif %}>Level 8</option>
          <option value="9" {% if user_pace_level == 9 %}selected{% endif %}>Level 9</option>
          <option value="10" {% if user_pace_level == 10 %}selected{% endif %}>Level 10</option>
        </select>
      </div>
      <button id="play-pause-btn" class="play-btn">▶</button>
      <button id="fullscreen-btn" class="fullscreen-btn" title="Fullscreen view">⛶</button>
      <div class="progress-controls">
        <label class="progress-label">
          <input type="checkbox" id="show-progress" checked> Show time into interval
        </label>
        <label class="sound-label">
          <input type="checkbox" id="sound-toggle" checked> Sound on
        </label>
      </div>
    </div>
  </div>

  <!-- Current Status -->
  <div class="workout-status">
    <div class="status-item">
      <span class="status-label">Time Left</span>
      <span id="time-left" class="status-value">{% widthratio ride.duration_seconds 60 1 %}:00</span>
    </div>
    <div class="status-item">
      <span class="status-label">Interval Time</span>
      <span id="interval-time" class="status-value">00:00</span>
    </div>
    <div class="status-item">
      <span class="status-label">Target</span>
      <span id="current-target" class="status-value">Loading...</span>
    </div>
  </div>
  
  <!-- Countdown Display -->
  <div id="countdown-display" class="countdown-display" style="display: none;">
    <div class="countdown-number">10</div>
    <div class="countdown-label">Starting in...</div>
  </div>
  
  <!-- Fullscreen Overlay -->
  <div id="fullscreen-overlay" class="fullscreen-overlay" style="display: none;">
    <div class="fullscreen-content">
      <button id="exit-fullscreen-btn" class="exit-fullscreen-btn" title="Exit fullscreen">✕</button>
      
      <!-- Fullscreen Status -->
      <div class="fullscreen-status">
        <div class="fullscreen-status-item">
          <span class="fullscreen-status-label">Time Left</span>
          <span id="fullscreen-time-left" class="fullscreen-status-value">{% widthratio ride.duration_seconds 60 1 %}:00</span>
        </div>
        <div class="fullscreen-status-item">
          <span class="fullscreen-status-label">Interval Time</span>
          <span id="fullscreen-interval-time" class="fullscreen-status-value">00:00</span>
        </div>
        <div class="fullscreen-status-item">
          <span class="fullscreen-status-label">Target</span>
          <span id="fullscreen-current-target" class="fullscreen-status-value">Loading...</span>
        </div>
      </div>
      
      <!-- Fullscreen Chart -->
      <div class="fullscreen-chart-container">
        <canvas id="fullscreen-class-plan-chart"></canvas>
        <div id="fullscreen-classPlanReadout" class="fullscreen-chart-readout"></div>
      </div>
      
      <!-- Fullscreen Controls -->
      <div class="fullscreen-controls">
        <div class="fullscreen-pace-level-control">
          <label for="fullscreen-pace-level-select">Pace Level:</label>
          <select id="fullscreen-pace-level-select" class="pace-level-select">
            <option value="1" {% if user_pace_level == 1 %}selected{% endif %}>Level 1</option>
            <option value="2" {% if user_pace_level == 2 %}selected{% endif %}>Level 2</option>
            <option value="3" {% if user_pace_level == 3 %}selected{% endif %}>Level 3</option>
            <option value="4" {% if user_pace_level == 4 %}selected{% endif %}>Level 4</option>
            <option value="5" {% if user_pace_level == 5 or not user_pace_level %}selected{% endif %}>Level 5</option>
            <option value="6" {% if user_pace_level == 6 %}selected{% endif %}>Level 6</option>
            <option value="7" {% if user_pace_level == 7 %}selected{% endif %}>Level 7</option>
            <option value="8" {% if user_pace_level == 8 %}selected{% endif %}>Level 8</option>
            <option value="9" {% if user_pace_level == 9 %}selected{% endif %}>Level 9</option>
            <option value="10" {% if user_pace_level == 10 %}selected{% endif %}>Level 10</option>
          </select>
        </div>
        <button id="fullscreen-play-pause-btn" class="fullscreen-play-btn">▶</button>
        <div class="fullscreen-progress-controls">
          <label class="progress-label">
            <input type="checkbox" id="fullscreen-show-progress" checked> Show time into interval
          </label>
          <label class="sound-label">
            <input type="checkbox" id="fullscreen-sound-toggle" checked> Sound on
          </label>
        </div>
      </div>
      
      <!-- Fullscreen Slider -->
      <div class="fullscreen-slider-container">
        <div class="fullscreen-slider-wrapper">
          <input type="range" id="fullscreen-progress-slider" min="0" max="100" value="0" class="fullscreen-progress-slider">
          <div id="fullscreen-slider-tooltip" class="slider-tooltip">0:00</div>
        </div>
        <div class="fullscreen-slider-labels">
          <span>0:00</span>
          <span id="fullscreen-slider-current-time">0:00</span>
          <span>{% widthratio ride.duration_seconds 60 1 %}:00</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Chart.js Chart -->
  <div class="interactive-chart-section">
    {% if playlist and playlist.songs %}
    <!-- Music Timeline Overlay - Above Chart -->
    <div class="mb-2 sm:mb-3 flex items-center justify-end gap-2">
      <label class="flex items-center gap-2 text-xs sm:text-sm text-gray-600 dark:text-gray-400 cursor-pointer">
        <input type="checkbox" id="showMusicTimeline" checked class="rounded border-gray-300 dark:border-gray-600 text-primary focus:ring-primary bg-white dark:bg-gray-700">
        <span>Show Music Timeline</span>
      </label>
    </div>
    <div id="musicTimeline" class="mb-2 sm:mb-3 h-10 sm:h-12 relative bg-gray-800 dark:bg-gray-950 rounded border border-gray-700 dark:border-gray-600 overflow-hidden"></div>
    {% endif %}
    <div class="pace-target-chart">
      <canvas id="class-plan-chart"></canvas>
      <div id="classPlanReadout" class="chart-readout"></div>
    </div>
    {{ chart_data|json_script:"chart-data" }}
    {% if target_line_data %}
    {{ target_line_data|json_script:"target-line-data" }}
    {% endif %}
    {% if user_pace_bands %}
    {{ user_pace_bands|json_script:"user-pace-bands" }}
    {% endif %}
    
    <!-- Chart Controls -->
    <div class="chart-controls">
      <button id="save-chart" class="chart-control-btn">
        <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path>
        </svg>
        Save
      </button>
      {% if target_line_data %}
      <button id="toggle-target-line" class="chart-control-btn">Hide Target</button>
      {% endif %}
      <label class="chart-control-checkbox">
        <input type="checkbox" id="toggle-zone-colors" checked>
        <span>Zone Colors</span>
      </label>
    </div>
    
    <!-- Progress Slider -->
    <div class="progress-slider-container">
      <div class="slider-wrapper">
        <input type="range" id="progress-slider" min="0" max="100" value="0" class="progress-slider">
        <div id="slider-tooltip" class="slider-tooltip">0:00</div>
      </div>
      <div class="slider-labels">
        <span>0:00</span>
        <span id="slider-current-time">0:00</span>
        <span>{% widthratio ride.duration_seconds 60 1 %}:00</span>
      </div>
    </div>
  </div>

</div>
{% endif %}

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Chart.js Implementation with Slider Integration
    (function() {
        const chartDataScript = document.getElementById('chart-data');
        if (!chartDataScript) return;
        
        const chartData = JSON.parse(chartDataScript.textContent || '{}');
        console.log('Chart data:', chartData);
        if (!chartData.segments || !chartData.zones) {
            console.log('Missing chart data - segments:', chartData.segments, 'zones:', chartData.zones);
            return;
        }
        
        // Get target line data if available
        const targetLineDataScript = document.getElementById('target-line-data');
        let targetLineData = null;
        if (targetLineDataScript) {
            try {
                const jsonText = targetLineDataScript.textContent;
                targetLineData = JSON.parse(jsonText || '[]');
                if (targetLineData && Array.isArray(targetLineData)) {
                    console.log('Target line data loaded:', targetLineData.length, 'points');
                    if (targetLineData.length > 0) {
                        console.log('First point:', targetLineData[0]);
                        console.log('Last point:', targetLineData[targetLineData.length - 1]);
                    }
                } else {
                    console.warn('Target line data is not an array:', typeof targetLineData);
                }
            } catch (e) {
                console.error('Error parsing target line data:', e);
                targetLineData = null;
            }
        } else {
            console.log('No target-line-data script tag found');
        }
        
        // Get ride length from chart data or fallback
        const rideLength = chartData.total_duration || 0;
        
        // Track target line visibility
        let showTargetLine = true;
        
        // Store target pace data for getCurrentTarget function
        let targetPaceData = [];
        
        // Get playlist data if available (for music timeline)
        const playlistData = {% if playlist and playlist.songs %}[
            {% for song in playlist.songs %}
            {
                title: "{{ song.title|escapejs }}",
                artists: [{% for artist in song.artists %}"{{ artist.artist_name|escapejs }}"{% if not forloop.last %}, {% endif %}{% endfor %}],
                start_time: {{ song.start_time_offset|default:0 }},
                duration: {{ song.duration|default:0 }}
            }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ]{% else %}[]{% endif %};
        
        // Calculate song durations if not provided
        if (playlistData && playlistData.length > 0) {
            const rideDuration = {{ ride.duration_seconds|default:0 }};
            for (let i = 0; i < playlistData.length; i++) {
                const song = playlistData[i];
                if (!song.start_time && song.start_time !== 0) {
                    song.start_time = 0;
                }
                if (!song.duration || song.duration <= 0) {
                    if (i < playlistData.length - 1) {
                        song.duration = playlistData[i + 1].start_time - song.start_time;
                    } else {
                        // Last song - use ride duration minus start time
                        song.duration = Math.max(180, rideDuration - song.start_time);
                    }
                }
            }
        }
        
        // Convert segments to time series data - show ACTUAL class plan pace targets
        const timePoints = [];
        const targetSeries = [];
        let segmentTime = 0;
        
        chartData.segments.forEach(segment => {
            const duration = segment.duration;
            // Use the actual class plan pace intensity (0-6) from target_metrics_data
            let target = segment.zone || segment.pace_level;
            
            // Debug the segment structure
            console.log('Raw segment:', segment);
            console.log('Class plan pace intensity:', target);
            
            // For running charts, ensure target is within 0-6 range (actual class plan)
            if (chartData.type === 'pace_target') {
                // If target is undefined/null, default to Recovery (0)
                if (target === undefined || target === null || isNaN(target)) {
                    target = 0;
                    console.log('Defaulting to Recovery (0) for segment');
                } else {
                    target = Math.max(0, Math.min(6, target));
                }
            }
            
            console.log('Class plan target (pace intensity):', target);
            
            // Add time points for this segment, ensuring continuous coverage
            for (let i = 0; i < duration && (segmentTime + i) < rideLength; i += 10) { // Every 10 seconds
                timePoints.push(segmentTime + i);
                targetSeries.push(target); // This is the ACTUAL class plan pace intensity
            }
            segmentTime += duration;
        });
        
        // Ensure we have a final point at the exact ride length
        if (rideLength > 0 && (timePoints.length === 0 || timePoints[timePoints.length - 1] < rideLength)) {
            timePoints.push(rideLength);
            targetSeries.push(targetSeries[targetSeries.length - 1] || 0); // Use last zone or default to Recovery (0)
        }
        
        // Ensure we have points every 10 seconds up to the total duration
        if (rideLength > 0) {
            const lastPoint = timePoints[timePoints.length - 1] || 0;
            for (let time = lastPoint + 10; time <= rideLength; time += 10) {
                timePoints.push(time);
                targetSeries.push(targetSeries[targetSeries.length - 1] || 1);
            }
        }
        
        // Calculate total duration - use ride length as authoritative source
        const totalDuration = rideLength || (timePoints.length > 0 ? timePoints[timePoints.length - 1] : 0);
        console.log('Time series generated:', { timePoints: timePoints.length, totalDuration, rideLength });
        
        // Create zone bands for background - matching workout_detail (pace levels 1-7)
        const zoneBands = chartData.zones.map((zone, index) => {
            // Convert from 0-6 index to 1-7 pace levels (matching workout_detail)
            const paceLevel = index + 1;
            return {
                label: zone.name,
                lower: paceLevel - 0.5,  // Contiguous bands (1-7 scale)
                upper: paceLevel + 0.5,
                color: zone.color
            };
        });
        
        // Zone band plugin - draw zone bands and overlay labels (matching power_zone_chart)
        const POWER_ZONE_COLORS = [
            '#9333ea',  // Zone 1 / Recovery
            '#3b82f6',  // Zone 2 / Easy
            '#10b981',  // Zone 3 / Moderate
            '#eab308',  // Zone 4 / Challenging
            '#f97316',  // Zone 5 / Hard
            '#ef4444',  // Zone 6 / Very Hard
            '#ec4899'   // Zone 7 / Max
        ];
        
        const PACE_LABELS = ['RECOVERY', 'EASY', 'MODERATE', 'CHALLENGING', 'HARD', 'VERY HARD', 'MAX'];
        
        let showZoneColors = true;
        
        const bandPlugin = {
            id: 'zoneBands',
            beforeDatasetsDraw(chart, args, opts) {
                if (!showZoneColors) return;
                const {ctx, chartArea, scales} = chart;
                if (!opts || !Array.isArray(opts.bands)) return;
                const toY = (zone) => scales.y.getPixelForValue(zone);
                ctx.save();
                (opts.bands || []).forEach(b => {
                    const yTop = toY(b.upper ?? 6);
                    const yBot = toY(b.lower ?? -1.5);
                    if (yTop == null || yBot == null) return;
                    ctx.fillStyle = b.color;
                    ctx.globalAlpha = 0.18;
                    ctx.fillRect(chartArea.left, yTop, chartArea.right - chartArea.left, yBot - yTop);
                });
                ctx.restore();
            },
            afterDraw(chart, args, opts) {
                // Overlay zone labels on the chart (matching workout_detail)
                if (!showZoneColors) return;
                const {ctx, chartArea, scales} = chart;
                ctx.save();
                ctx.font = '12px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                if (chartData.type === 'pace_target') {
                    // Draw pace labels (1-7) overlaid on the chart (matching workout_detail)
                    // PACE_LABELS: ['RECOVERY', 'EASY', 'MODERATE', 'CHALLENGING', 'HARD', 'VERY HARD', 'MAX']
                    // Map to levels 1-7: Recovery=1, Easy=2, Moderate=3, etc.
                    for (let level = 1; level <= 7; level++) {
                        const yPos = scales.y.getPixelForValue(level);
                        if (yPos < chartArea.top || yPos > chartArea.bottom) continue;
                        // Position labels on the left side of the chart area
                        // level 1 = Recovery (index 0), level 2 = Easy (index 1), etc.
                        const labelIndex = level - 1;
                        ctx.fillText(PACE_LABELS[labelIndex] || `LEVEL ${level}`, chartArea.left + 8, yPos);
                    }
                } else {
                    // Draw zone labels (1-7) overlaid on the chart
                    for (let zone = 1; zone <= 7; zone++) {
                        const yPos = scales.y.getPixelForValue(zone);
                        if (yPos < chartArea.top || yPos > chartArea.bottom) continue;
                        // Position labels on the left side of the chart area
                        ctx.fillText(`ZONE ${zone}`, chartArea.left + 8, yPos);
                    }
                }
                
                ctx.restore();
            }
        };
        
        // Progress line plugin
        const progressLinePlugin = {
            id: 'progressLine',
            afterDatasetsDraw(chart, args, opts) {
                const {ctx, chartArea, scales} = chart;
                if (!opts || opts.currentTime === undefined) return;
                
                const x = scales.x.getPixelForValue(opts.currentTime);
                if (x < chartArea.left || x > chartArea.right) return;
                
                ctx.save();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(x, chartArea.top);
                ctx.lineTo(x, chartArea.bottom);
                ctx.stroke();
                ctx.restore();
            }
        };
        
        // Function to get pace value for a given level (defined before tooltip)
        // Get user pace bands from backend (if available)
        const userPaceBandsData = JSON.parse(document.getElementById('user-pace-bands')?.textContent || 'null');
        
        function getPaceForLevel(classPlanIntensity, userLevel = 5) {
            // Convert class plan pace intensity (0-6) to min/mi based on user's selected level (1-10)
            // Uses actual PaceBand data from user's profile if available, otherwise falls back to defaults
            
            // Map class plan intensity (0-6) to intensity labels
            const intensityLabels = ['Recovery', 'Easy', 'Moderate', 'Challenging', 'Hard', 'Very Hard', 'Max'];
            const label = intensityLabels[classPlanIntensity] || 'Moderate';
            
            // Use actual user pace bands if available
            if (userPaceBandsData && userPaceBandsData.length > 0) {
                // Map intensity index (0-6) to zone names used in PaceBand
                const zoneMap = {
                    0: 'recovery',
                    1: 'easy',
                    2: 'moderate',
                    3: 'challenging',
                    4: 'hard',
                    5: 'very_hard',
                    6: 'max'
                };
                const zoneKey = zoneMap[classPlanIntensity];
                
                if (zoneKey) {
                    const band = userPaceBandsData.find(b => b.zone === zoneKey);
                    if (band) {
                        // Use the middle of the pace range
                        const minPace = band.min_pace;
                        const maxPace = band.max_pace;
                        const pace = (minPace + maxPace) / 2;
                        const minutes = Math.floor(pace);
                        const seconds = Math.round((pace - minutes) * 60);
                        
                        console.log(`Using user pace band for ${label} (${zoneKey}): ${minPace}-${maxPace} min/mile, calculated pace: ${minutes}:${seconds.toString().padStart(2, '0')}`);
                        
                        return {
                            pace: `${minutes}:${seconds.toString().padStart(2, '0')}`,
                            label: label,
                        };
                    }
                }
            }
            
            // Fallback to hardcoded pace ranges (for backwards compatibility or if no bands available)
            // Pace ranges from PaceTarget model for each user level (1-10)
            // Level 1 = slowest (highest min/mile), Level 10 = fastest (lowest min/mile)
            // Values are in decimal minutes per mile (e.g., 18.183 = 18:11 min/mile)
            const paceRangesByLevel = {
                1: {
                    "Recovery": [20.0, 60.0],      // 20:00 - 60:00 min/mile
                    "Easy": [18.183, 20.0],         // 18:11 - 20:00 min/mile
                    "Moderate": [16.667, 18.183],   // 16:40 - 18:11 min/mile
                    "Challenging": [15.0, 16.667],  // 15:00 - 16:40 min/mile
                    "Hard": [13.633, 15.0],         // 13:38 - 15:00 min/mile
                    "Very Hard": [12.25, 13.633],   // 12:15 - 13:38 min/mile
                    "Max": [4.8, 12.25]             // 4:48 - 12:15 min/mile
                },
                2: {
                    "Recovery": [18.75, 60.0],      // 18:45 - 60:00 min/mile
                    "Easy": [16.667, 18.75],        // 16:40 - 18:45 min/mile
                    "Moderate": [15.383, 16.667],   // 15:23 - 16:40 min/mile
                    "Challenging": [13.95, 15.383], // 13:57 - 15:23 min/mile
                    "Hard": [12.767, 13.95],        // 12:46 - 13:57 min/mile
                    "Very Hard": [11.533, 12.767],  // 11:32 - 12:46 min/mile
                    "Max": [4.8, 11.533]            // 4:48 - 11:32 min/mile
                },
                3: {
                    "Recovery": [17.133, 60.0],    // 17:08 - 60:00 min/mile
                    "Easy": [15.383, 17.133],       // 15:23 - 17:08 min/mile
                    "Moderate": [14.283, 15.383],   // 14:17 - 15:23 min/mile
                    "Challenging": [13.05, 14.283], // 13:03 - 14:17 min/mile
                    "Hard": [11.767, 13.05],        // 11:46 - 13:03 min/mile
                    "Very Hard": [10.717, 11.767],   // 10:43 - 11:46 min/mile
                    "Max": [4.8, 10.717]            // 4:48 - 10:43 min/mile
                },
                4: {
                    "Recovery": [16.217, 60.0],     // 16:13 - 60:00 min/mile
                    "Easy": [15.217, 16.217],       // 15:13 - 16:13 min/mile
                    "Moderate": [13.333, 15.217],   // 13:20 - 15:13 min/mile
                    "Challenging": [12.0, 13.333],  // 12:00 - 13:20 min/mile
                    "Hard": [11.117, 12.0],         // 11:07 - 12:00 min/mile
                    "Very Hard": [9.833, 11.117],   // 9:50 - 11:07 min/mile
                    "Max": [4.8, 9.833]             // 4:48 - 9:50 min/mile
                },
                5: {
                    "Recovery": [15.217, 60.0],     // 15:13 - 60:00 min/mile
                    "Easy": [13.333, 15.217],       // 13:20 - 15:13 min/mile
                    "Moderate": [12.25, 13.333],    // 12:15 - 13:20 min/mile
                    "Challenging": [11.117, 12.25], // 11:07 - 12:15 min/mile
                    "Hard": [10.0, 11.117],         // 10:00 - 11:07 min/mile
                    "Very Hard": [9.083, 10.0],     // 9:05 - 10:00 min/mile
                    "Max": [4.8, 9.083]             // 4:48 - 9:05 min/mile
                },
                6: {
                    "Recovery": [13.333, 60.0],        // 13:20 - 60:00 min/mile
                    "Easy": [12.25, 13.333],        // 12:15 - 13:20 min/mile
                    "Moderate": [11.117, 12.25],    // 11:07 - 12:15 min/mile
                    "Challenging": [10.0, 11.117],  // 10:00 - 11:07 min/mile
                    "Hard": [9.083, 10.0],          // 9:05 - 10:00 min/mile
                    "Very Hard": [8.217, 9.083],    // 8:13 - 9:05 min/mile
                    "Max": [4.8, 8.217]             // 4:48 - 8:13 min/mile
                },
                7: {
                    "Recovery": [12.0, 60.0],       // 12:00 - 60:00 min/mile
                    "Easy": [10.9, 12.0],           // 10:54 - 12:00 min/mile
                    "Moderate": [10.0, 10.9],       // 10:00 - 10:54 min/mile
                    "Challenging": [8.95, 10.0],    // 8:57 - 10:00 min/mile
                    "Hard": [8.217, 8.95],          // 8:13 - 8:57 min/mile
                    "Very Hard": [7.4, 8.217],      // 7:24 - 8:13 min/mile
                    "Max": [4.8, 7.4]               // 4:48 - 7:24 min/mile
                },
                8: {
                    "Recovery": [10.5, 60.0],       // 10:30 - 60:00 min/mile
                    "Easy": [9.683, 10.5],          // 9:41 - 10:30 min/mile
                    "Moderate": [8.817, 9.683],     // 8:49 - 9:41 min/mile
                    "Challenging": [8.0, 8.817],    // 8:00 - 8:49 min/mile
                    "Hard": [7.317, 8.0],           // 7:19 - 8:00 min/mile
                    "Very Hard": [6.583, 7.317],    // 6:35 - 7:19 min/mile
                    "Max": [4.8, 6.583]             // 4:48 - 6:35 min/mile
                },
                9: {
                    "Recovery": [9.217, 60.0],      // 9:13 - 60:00 min/mile
                    "Easy": [8.333, 9.217],         // 8:20 - 9:13 min/mile
                    "Moderate": [7.7, 8.333],        // 7:42 - 8:20 min/mile
                    "Challenging": [6.983, 7.7],    // 6:59 - 7:42 min/mile
                    "Hard": [6.383, 6.983],         // 6:23 - 6:59 min/mile
                    "Very Hard": [5.767, 6.383],   // 5:46 - 6:23 min/mile
                    "Max": [4.8, 5.767]             // 4:48 - 5:46 min/mile
                },
                10: {
                    "Recovery": [7.9, 60.0],        // 7:54 - 60:00 min/mile
                    "Easy": [7.15, 7.9],           // 7:09 - 7:54 min/mile
                    "Moderate": [6.667, 7.15],      // 6:40 - 7:09 min/mile
                    "Challenging": [6.0, 6.667],    // 6:00 - 6:40 min/mile
                    "Hard": [5.5, 6.0],            // 5:30 - 6:00 min/mile
                    "Very Hard": [4.917, 5.5],      // 4:55 - 5:30 min/mile
                    "Max": [4.8, 4.917]             // 4:48 - 4:55 min/mile
                }
            };
            
            // Clamp user level to valid range
            const clampedLevel = Math.max(1, Math.min(10, userLevel));
            const levelRanges = paceRangesByLevel[clampedLevel] || paceRangesByLevel[5];
            
            // Get the range for the current intensity
            const range = levelRanges[label] || levelRanges['Moderate'];
            const [minPace, maxPace] = range;
            
            // Use middle of the range
            const pace = (minPace + maxPace) / 2;
            const minutes = Math.floor(pace);
            const seconds = Math.round((pace - minutes) * 60);
            
            return {
                pace: `${minutes}:${seconds.toString().padStart(2, '0')}`,
                label: label,
                classPlanIntensity: classPlanIntensity
            };
        }
        
        // Readout display (top-right corner) - update on chart hover
        const readout = document.getElementById('classPlanReadout');
        
        // Create the chart
        const ctx2d = document.getElementById('class-plan-chart').getContext('2d');
        console.log('Creating chart with data points:', timePoints.length);
        console.log('Time points range:', timePoints[0], 'to', timePoints[timePoints.length-1]);
        console.log('Total duration:', totalDuration);
        
        // Build datasets array
        const datasets = [];
        
        // Add "Class Plan" dataset (hidden if target line is available)
        // Convert from 0-6 scale to 1-7 scale to match workout_detail
        const classPlanData = timePoints.map((time, index) => {
            const zoneValue = targetSeries[index];
            // Convert from 0-6 (class library) to 1-7 (workout_detail)
            const paceLevel = zoneValue !== null && zoneValue !== undefined ? zoneValue + 1 : 2;
            return { x: time, y: Math.max(1, Math.min(7, Math.round(paceLevel))) };
        });
        
        datasets.push({
            label: chartData.type === 'pace_target' ? 'Class Plan' : 'Target Zone',
            data: classPlanData,
            borderWidth: 3,
            pointRadius: 0,
            borderColor: '#5b7cfa',
            backgroundColor: 'rgba(91, 124, 250, 0.1)',
            fill: true,
            tension: 0.1,
            hidden: true  // Always hide class plan when we have target line (matching workout_detail)
        });
        
        // Add target line dataset - calculate from segments (matching workout_detail approach exactly)
        // For pace targets, we calculate the target line directly from chartData.segments
        // This matches how workout_detail does it (not using backend target_line_data)
        if (chartData.segments && chartData.segments.length > 0) {
            console.log('Calculating target line from segments:', chartData.segments.length);
            
            // Shift target line 60 seconds backwards (earlier) to match power zone behavior
            // This matches workout_detail exactly
            const TIME_SHIFT = -60;
            
            // Use the outer scope targetPaceData variable
            targetPaceData = [];
            // Generate time points every 5 seconds for the class duration (matching workout_detail)
            const timePoints = [];
            for (let t = 0; t <= totalDuration; t += 5) {
                timePoints.push(t);
            }
            
            console.log('Generated time points:', timePoints.length, 'for duration:', totalDuration);
            
            for (let i = 0; i < timePoints.length; i++) {
                const currentTime = timePoints[i];
                // Find which segment this time belongs to (with 60 second backward shift, matching workout_detail)
                let targetPace = null;
                for (const segment of chartData.segments) {
                    // Apply 60 second backward shift to segment times (matching workout_detail)
                    const segStart = Math.max(0, (segment.start || 0) + TIME_SHIFT);
                    const segEnd = Math.max(0, (segment.end || (segment.start || 0) + (segment.duration || 0)) + TIME_SHIFT);
                    
                    if (currentTime >= segStart && currentTime < segEnd) {
                        // Get zone/pace_level from segment
                        // Class library uses 0-6, but workout_detail uses 1-7, so convert
                        let zoneValue = segment.zone !== null && segment.zone !== undefined 
                            ? segment.zone 
                            : (segment.pace_level !== null && segment.pace_level !== undefined 
                                ? segment.pace_level 
                                : 1); // Default to Easy (1 in 0-6 scale, which is 2 in 1-7 scale)
                        
                        // Convert from 0-6 scale (class library) to 1-7 scale (workout_detail)
                        // 0 (Recovery) -> 1, 1 (Easy) -> 2, 2 (Moderate) -> 3, etc.
                        targetPace = zoneValue + 1;
                        break;
                    }
                }
                
                // If no segment found, use the last segment's pace or default
                if (targetPace === null && chartData.segments.length > 0) {
                    const lastSegment = chartData.segments[chartData.segments.length - 1];
                    let zoneValue = lastSegment.zone !== null && lastSegment.zone !== undefined
                        ? lastSegment.zone
                        : (lastSegment.pace_level !== null && lastSegment.pace_level !== undefined
                            ? lastSegment.pace_level
                            : 1); // Default to Easy
                    targetPace = zoneValue + 1; // Convert to 1-7 scale
                }
                
                if (targetPace !== null) {
                    // Ensure pace level is in valid range (1-7 for pace targets, matching workout_detail)
                    const clampedPace = Math.max(1, Math.min(7, Math.round(targetPace)));
                    targetPaceData.push({ x: currentTime, y: clampedPace });
                }
            }
            
            console.log('Target pace data generated:', targetPaceData.length, 'points');
            if (targetPaceData.length > 0) {
                console.log('First target point:', targetPaceData[0]);
                console.log('Last target point:', targetPaceData[targetPaceData.length - 1]);
                console.log('Target line Y-axis range:', 
                    Math.min(...targetPaceData.map(p => p.y)), 
                    'to', 
                    Math.max(...targetPaceData.map(p => p.y))
                );
            }
            
            if (targetPaceData.length > 0) {
                datasets.push({
                    label: 'Target',
                    data: targetPaceData,
                    borderColor: '#93c5fd',  // Light blue like power zone
                    backgroundColor: 'rgba(147, 197, 253, 0.1)',
                    borderWidth: 2.8,
                    fill: false,
                    tension: 0,  // Stepped line (no smoothing)
                    stepped: 'before',  // Stepped line
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    spanGaps: true,
                    hidden: false  // Always show by default - user can toggle
                });
                
                console.log('Target line dataset added. Total datasets:', datasets.length);
            } else {
                console.warn('Target pace data is empty after generation');
            }
        } else {
            console.log('No segments available for target line calculation. chartData.segments:', chartData.segments);
        }
        
        // Use line chart for both cycling and running
        chartDataConfig = {
            type: 'line',
            data: {
                datasets: datasets
            }
        };
        
        const chartConfig = {
            ...chartDataConfig,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { display: false },
                    tooltip: { 
                        enabled: true,  // Use Chart.js tooltip
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                if (context.length > 0 && context[0].parsed) {
                                    const timestamp = context[0].parsed.x;
                                    const minutes = Math.floor(timestamp / 60);
                                    const seconds = Math.floor(timestamp % 60);
                                    return `${minutes}:${seconds.toString().padStart(2,'0')}`;
                                }
                                return '';
                            },
                            label: function(context) {
                                const datasetLabel = context.dataset.label;
                                const zoneValue = context.parsed.y;
                                
                                if (chartData.type === 'pace_target') {
                                    // Get user pace level from select
                                    const paceLevelSelect = document.getElementById('pace-level-select');
                                    const userLevel = parseInt(paceLevelSelect?.value || '{{ user_pace_level|default:5 }}') || 5;
                                    
                                    if (datasetLabel === 'Target') {
                                        // Target line uses 1-7 scale, convert to 0-6 for getPaceForLevel
                                        const zoneNum = Math.max(0, Math.min(6, Math.round(zoneValue) - 1));
                                        const paceInfo = getPaceForLevel(zoneNum, userLevel);
                                        return `Target: ${paceInfo.pace} /mi (${paceInfo.label})`;
                                    } else if (datasetLabel === 'Class Plan') {
                                        // Class Plan also uses 1-7 scale (converted from 0-6), convert back to 0-6
                                        const zoneNum = Math.max(0, Math.min(6, Math.round(zoneValue) - 1));
                                        const paceInfo = getPaceForLevel(zoneNum, userLevel);
                                        return `Class Plan: ${paceInfo.label}`;
                                    }
                                }
                                
                                return `${datasetLabel}: Zone ${Math.round(zoneValue)}`;
                            }
                        },
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: 'rgba(255, 255, 255, 0.9)',
                        bodyColor: 'rgba(255, 255, 255, 0.9)',
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        padding: 12
                    },
                    zoneBands: { bands: zoneBands },
                    progressLine: { currentTime: 0 }
                },
                scales: {
                    x: {
                        type: 'linear',
                        min: 0,
                        max: totalDuration,
                        grid: { 
                            color: document.documentElement.classList.contains('dark') 
                                ? 'rgba(255,255,255,0.06)' 
                                : 'rgba(0,0,0,0.05)' 
                        },
                        ticks: {
                            autoSkip: true,
                            maxTicksLimit: 9,
                            color: document.documentElement.classList.contains('dark')
                                ? 'rgba(255,255,255,0.7)'
                                : 'rgba(0,0,0,0.7)',
                            callback: (value) => {
                                const minutes = Math.floor(value / 60);
                                const seconds = Math.floor(value % 60);
                                return `${minutes}:${seconds.toString().padStart(2,'0')}`;
                            }
                        }
                    },
                    y: {
                        min: 0.5,  // Match workout_detail (pace levels 1-7)
                        max: 7.5,  // Match workout_detail (pace levels 1-7)
                        title: { 
                            display: false,  // Hide y-axis title (labels are overlaid on chart)
                            text: chartData.type === 'pace_target' ? 'Pace Level' : 'Zone',
                            color: document.documentElement.classList.contains('dark')
                                ? 'rgba(255,255,255,0.7)'
                                : 'rgba(0,0,0,0.7)'
                        },
                        grid: { 
                            color: document.documentElement.classList.contains('dark') 
                                ? 'rgba(255,255,255,0.06)' 
                                : 'rgba(0,0,0,0.05)' 
                        },
                        ticks: { 
                            stepSize: 1,
                            maxTicksLimit: 8,
                            drawTicks: false  // Hide ticks - zone labels are overlaid on chart
                        },
                        display: false  // Hide ticks on left - zone labels are overlaid on chart
                    }
                }
            },
            plugins: [bandPlugin, progressLinePlugin]
        };
        
        const chart = new Chart(ctx2d, chartConfig);
        
        // Slider integration
        const progressSlider = document.getElementById('progress-slider');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const timeLeftEl = document.getElementById('time-left');
        const intervalTimeEl = document.getElementById('interval-time');
        const currentTargetEl = document.getElementById('current-target');
        const paceLevelSelect = document.getElementById('pace-level-select');
        
        let isPlaying = false;
        let chartCurrentTime = 0;
        let animationId = null;
        let startTime = null;
        let pausedTime = 0;
        let lastUpdateTime = 0;
        let lastSegmentIndex = -1;
        let countdownBeepTimes = new Set(); // Track when we've already beeped for countdown
        let hasStarted = false; // Track if workout has started (for initial countdown)
        let countdownInterval = null; // Track countdown interval
        
        // Audio for beeps
        let countdownAudio = null;
        let intervalChangeAudio = null;
        
        function initAudio() {
            // Get static URL for the audio file
            const audioUrl = '{% static "media/short-beep-countdown.mp3" %}';
            
            if (!countdownAudio) {
                try {
                    countdownAudio = new Audio(audioUrl);
                    countdownAudio.volume = 0.7;
                    countdownAudio.preload = 'auto';
                } catch (e) {
                    console.warn('Error loading countdown audio:', e);
                }
            }
            if (!intervalChangeAudio) {
                try {
                    intervalChangeAudio = new Audio(audioUrl);
                    intervalChangeAudio.volume = 0.7;
                    intervalChangeAudio.preload = 'auto';
                } catch (e) {
                    console.warn('Error loading interval change audio:', e);
                }
            }
        }
        
        function playCountdownAudio() {
            const soundToggle = document.getElementById('sound-toggle');
            if (!soundToggle || !soundToggle.checked) {
                return; // Sound is disabled
            }
            
            // Use the MP3 file for countdown (starts 3 seconds before interval change)
            if (countdownAudio) {
                try {
                    // Reset to beginning if already playing
                    countdownAudio.currentTime = 0;
                    countdownAudio.play().catch(e => {
                        console.warn('Error playing countdown audio:', e);
                    });
                } catch (e) {
                    console.warn('Error playing countdown audio:', e);
                }
            }
        }
        
        function playBeep(frequency = 800, duration = 100, type = 'sine') {
            const soundToggle = document.getElementById('sound-toggle');
            if (!soundToggle || !soundToggle.checked) {
                return; // Sound is disabled
            }
            
            // Fallback to Web Audio API for countdown beeps
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
            } catch (e) {
                console.warn('Error playing beep:', e);
            }
        }
        
        function startCountdown(callback) {
            const soundToggle = document.getElementById('sound-toggle');
            const soundEnabled = soundToggle && soundToggle.checked;
            
            let countdown = 10;
            const countdownDisplay = document.getElementById('countdown-display');
            const countdownNumber = countdownDisplay ? countdownDisplay.querySelector('.countdown-number') : null;
            
            // Show countdown display if it exists
            if (countdownDisplay) {
                countdownDisplay.style.display = 'block';
                if (countdownNumber) {
                    countdownNumber.textContent = countdown;
                }
            }
            
            // Play initial beep
            if (soundEnabled) {
                playBeep(600, 100, 'sine');
            }
            
            countdownInterval = setInterval(() => {
                countdown--;
                
                // Update display
                if (countdownNumber) {
                    countdownNumber.textContent = countdown;
                }
                
                // Play beep for each second
                if (soundEnabled && countdown > 0) {
                    playBeep(600, 100, 'sine');
                }
                
                // When countdown reaches 0, start the workout
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    
                    // Hide countdown display
                    if (countdownDisplay) {
                        countdownDisplay.style.display = 'none';
                    }
                    
                    // Play final beep (higher pitch)
                    if (soundEnabled) {
                        playBeep(1000, 200, 'sine');
                    }
                    
                    // Start the workout
                    hasStarted = true;
                    callback();
                }
            }, 1000);
        }
        
        function getSegmentIndex(time) {
            let segmentTime = 0;
            for (let i = 0; i < chartData.segments.length; i++) {
                const segment = chartData.segments[i];
                const segmentEnd = segmentTime + segment.duration;
                if (time >= segmentTime && time < segmentEnd) {
                    return i;
                }
                segmentTime = segmentEnd;
            }
            return chartData.segments.length - 1; // Return last segment if at end
        }
        
        function checkIntervalChangeAndCountdown() {
            if (!chartData || !chartData.segments || chartData.segments.length === 0) return;
            
            const currentSegment = getCurrentSegment(chartCurrentTime);
            if (!currentSegment) return;
            
            const currentSegmentIndex = getSegmentIndex(chartCurrentTime);
            const timeRemainingInSegment = currentSegment.endTime - chartCurrentTime;
            
            // Start countdown audio 3 seconds before interval change
            if (timeRemainingInSegment > 0 && timeRemainingInSegment <= 3) {
                const beepKey = `${currentSegmentIndex}-countdown`;
                
                // Only play once per segment (when we first hit 3 seconds remaining)
                if (!countdownBeepTimes.has(beepKey) && timeRemainingInSegment <= 3 && timeRemainingInSegment > 2.9) {
                    playCountdownAudio();
                    countdownBeepTimes.add(beepKey);
                }
            }
            
            // Check for interval change (track segment changes)
            if (currentSegmentIndex !== lastSegmentIndex) {
                lastSegmentIndex = currentSegmentIndex;
                countdownBeepTimes.clear(); // Reset countdown tracking for new segment
            }
        }
        
        function updateProgress() {
            if (totalDuration === 0) return;
            
            const progress = (chartCurrentTime / totalDuration) * 100;
            progressSlider.value = Math.round(progress * 100) / 100; // Round to 2 decimal places
            
            // Update slider current time display
            const sliderCurrentTime = document.getElementById('slider-current-time');
            if (sliderCurrentTime) {
                const minutes = Math.floor(chartCurrentTime / 60);
                const seconds = Math.floor(chartCurrentTime % 60);
                sliderCurrentTime.textContent = minutes + ':' + String(seconds).padStart(2, '0');
            }
            
            // Update time displays
            const timeLeft = Math.max(0, totalDuration - chartCurrentTime);
            const minutesLeft = Math.floor(timeLeft / 60);
            const secondsLeft = Math.floor(timeLeft % 60);
            timeLeftEl.textContent = minutesLeft + ':' + String(secondsLeft).padStart(2, '0');
            
            // Debug logging
            console.log(`Total Duration: ${totalDuration}, Current Time: ${chartCurrentTime}, Time Left: ${timeLeft}`);
            
            // Update interval time - show time within current segment, not total elapsed time
            const currentSegment = getCurrentSegment(chartCurrentTime);
            const showProgressCheckbox = document.getElementById('show-progress');
            const showProgressUp = showProgressCheckbox ? showProgressCheckbox.checked : true;
            
            let intervalTime;
            if (currentSegment) {
                if (showProgressUp) {
                    intervalTime = chartCurrentTime - currentSegment.startTime;
                } else {
                    intervalTime = currentSegment.endTime - chartCurrentTime;
                }
            } else {
                intervalTime = 0;
            }
            
            const intervalMinutes = Math.floor(Math.max(0, intervalTime) / 60);
            const intervalSeconds = Math.floor(Math.max(0, intervalTime) % 60);
            intervalTimeEl.textContent = intervalMinutes + ':' + String(intervalSeconds).padStart(2, '0');
            
            // Update current target - use the same logic as chart tooltip
            const currentTarget = getCurrentTarget(chartCurrentTime);
            if (currentTarget !== null && currentTarget !== undefined) {
                if (chartData.type === 'pace_target') {
                    // For running, convert class plan intensity to min/mi based on user's level
                    const userLevel = parseInt(paceLevelSelect.value) || 5;
                    const paceInfo = getPaceForLevel(currentTarget, userLevel);
                    currentTargetEl.textContent = `${paceInfo.pace} @ ${paceInfo.label}`;
                    
                    // Debug logging to match chart tooltip
                    console.log(`Chart Current Time: ${chartCurrentTime}, Current Target: ${currentTarget}, Pace Info:`, paceInfo);
                } else {
                    // For cycling, show power target
                    const ftp = parseInt(ftpInput?.value || 250) || 250;
                    const targetOutput = Math.round(ftp * getZonePercentage(currentTarget));
                    currentTargetEl.textContent = String(targetOutput) + ' @ Zone ' + currentTarget;
                }
            } else {
                // Fallback if no target found
                currentTargetEl.textContent = 'Loading...';
            }
            
            // Debug logging for timing
            console.log(`Current Segment:`, currentSegment);
            console.log(`Interval Time: ${intervalMinutes}:${String(intervalSeconds).padStart(2, '0')}, Chart Current Time: ${chartCurrentTime}`);
            
            // Update chart progress line
            chart.options.plugins.progressLine.currentTime = chartCurrentTime;
            console.log(`Setting progress line to: ${chartCurrentTime} seconds (${Math.floor(chartCurrentTime/60)}:${Math.floor(chartCurrentTime%60).toString().padStart(2,'0')})`);
            chart.update('none');
            
            // Update fullscreen display if active
            if (typeof updateFullscreenDisplay === 'function') {
                updateFullscreenDisplay();
                updateFullscreenPlayButton();
            }
            
            // Check for interval changes and countdown beeps (only when playing)
            if (isPlaying) {
                checkIntervalChangeAndCountdown();
            } else {
                // When not playing (scrubbing), still track segment changes but don't beep
                const currentSegmentIndex = getSegmentIndex(chartCurrentTime);
                if (currentSegmentIndex !== lastSegmentIndex) {
                    lastSegmentIndex = currentSegmentIndex;
                    countdownBeepTimes.clear();
                }
            }
        }
        
        function getCurrentTarget(time) {
            // First try to use targetPaceData (from target line calculation, uses 1-7 scale)
            if (targetPaceData && targetPaceData.length > 0) {
                // Find the closest target point to the current time
                let closestPoint = null;
                let minDiff = Infinity;
                for (const point of targetPaceData) {
                    const diff = Math.abs(point.x - time);
                    if (diff < minDiff && diff < 10) { // Within 10 seconds
                        minDiff = diff;
                        closestPoint = point;
                    }
                }
                if (closestPoint && closestPoint.y !== null && closestPoint.y !== undefined) {
                    // Target line uses 1-7 scale, convert to 0-6 for getPaceForLevel
                    const paceLevel = closestPoint.y - 1;
                    console.log(`getCurrentTarget: Using target line data. Time: ${time}, Target pace level: ${closestPoint.y} (1-7), Converted: ${paceLevel} (0-6)`);
                    return paceLevel;
                }
            }
            
            // Fallback to segments (0-6 scale)
            // Use segment.start/end times (matching workout_detail approach)
            for (const segment of chartData.segments) {
                const segStart = segment.start || 0;
                const segEnd = segment.end || (segStart + (segment.duration || 0));
                if (time >= segStart && time < segEnd) {
                    // Handle both power zones (cycling) and pace levels (running)
                    // Segments use 0-6 scale for pace targets
                    const zoneValue = segment.zone !== null && segment.zone !== undefined 
                        ? segment.zone 
                        : (segment.pace_level !== null && segment.pace_level !== undefined 
                            ? segment.pace_level 
                            : 1); // Default to Easy (1 in 0-6 scale)
                    console.log(`getCurrentTarget: Using segment data. Time: ${time}, Segment zone: ${zoneValue} (0-6)`);
                    return zoneValue;
                }
            }
            console.log(`getCurrentTarget: No match found, defaulting to Easy (1)`);
            return 1; // Default to Easy (1 in 0-6 scale, which is 2 in 1-7 scale)
        }
        
        function getCurrentSegment(time) {
            let segmentTime = 0;
            for (const segment of chartData.segments) {
                const segmentEnd = segmentTime + segment.duration;
                if (time >= segmentTime && time < segmentEnd) {
                    return {
                        ...segment,
                        startTime: segmentTime,
                        endTime: segmentEnd
                    };
                }
                segmentTime = segmentEnd;
            }
            return null; // No segment found
        }
        
        function getZonePercentage(zone) {
            const zonePercentages = {
                1: 0.55,  // Zone 1: 55% of FTP
                2: 0.75,  // Zone 2: 75% of FTP
                3: 0.90,  // Zone 3: 90% of FTP
                4: 1.05,  // Zone 4: 105% of FTP
                5: 1.20,  // Zone 5: 120% of FTP
                6: 1.50,  // Zone 6: 150% of FTP
            };
            return zonePercentages[zone] || 0.90;
        }
        
        function play() {
            if (totalDuration === 0) return;
            
            // If workout hasn't started and we're at the beginning, do countdown
            if (!hasStarted && chartCurrentTime === 0) {
                startCountdown(() => {
                    // This callback runs after countdown completes
                    isPlaying = true;
                    playPauseBtn.textContent = '⏸';
                    playPauseBtn.classList.add('paused');
                    
                    // Record start time for accurate timing
                    startTime = Date.now();
                    
                    function animate() {
                        if (!isPlaying) return;
                        
                        // Calculate elapsed time accurately
                        const elapsed = (Date.now() - startTime) / 1000;
                        chartCurrentTime = Math.min(elapsed, totalDuration);
                        
                        // Throttle updates to every 100ms for smoother performance
                        const now = Date.now();
                        if (now - lastUpdateTime >= 100) {
                            updateProgress();
                            lastUpdateTime = now;
                        }
                        
                        if (chartCurrentTime >= totalDuration) {
                            pause();
                            return;
                        }
                        
                        // Use requestAnimationFrame for smoother updates
                        animationId = requestAnimationFrame(animate);
                    }
                    
                    animate();
                });
                return; // Exit early, countdown will start the workout
            }
            
            // Resume playback (workout already started)
            isPlaying = true;
            playPauseBtn.textContent = '⏸';
            playPauseBtn.classList.add('paused');
            
            // Record start time for accurate timing
            startTime = Date.now() - (chartCurrentTime * 1000);
            
            function animate() {
                if (!isPlaying) return;
                
                // Calculate elapsed time accurately
                const elapsed = (Date.now() - startTime) / 1000;
                chartCurrentTime = Math.min(elapsed, totalDuration);
                
                // Throttle updates to every 100ms for smoother performance
                const now = Date.now();
                if (now - lastUpdateTime >= 100) {
                    updateProgress();
                    lastUpdateTime = now;
                }
                
                if (chartCurrentTime >= totalDuration) {
                    pause();
                    return;
                }
                
                // Use requestAnimationFrame for smoother updates
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function pause() {
            isPlaying = false;
            playPauseBtn.textContent = '▶';
            playPauseBtn.classList.remove('paused');
            
            // Cancel countdown if it's running
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
                const countdownDisplay = document.getElementById('countdown-display');
                if (countdownDisplay) {
                    countdownDisplay.style.display = 'none';
                }
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // Event listeners
        playPauseBtn.addEventListener('click', function() {
            if (isPlaying) {
                pause();
            } else {
                play();
            }
        });
        
        const sliderTooltip = document.getElementById('slider-tooltip');
        const sliderCurrentTime = document.getElementById('slider-current-time');
        
        function updateSliderTooltip(value) {
            if (!sliderTooltip || !sliderCurrentTime) return;
            
            const time = (value / 100) * totalDuration;
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const timeString = minutes + ':' + String(seconds).padStart(2, '0');
            
            sliderTooltip.textContent = timeString;
            sliderCurrentTime.textContent = timeString;
            
            const percentage = (value / 100);
            sliderTooltip.style.left = (percentage * 100) + '%';
        }
        
        progressSlider.addEventListener('input', function() {
            const progress = parseFloat(this.value);
            chartCurrentTime = (progress / 100) * totalDuration;
            
            updateSliderTooltip(progress);
            
            // Update start time to maintain sync when manually scrubbing
            if (isPlaying) {
                startTime = Date.now() - (chartCurrentTime * 1000);
            }
            
            updateProgress();
        });
        
        // Show tooltip on hover and update position
        progressSlider.addEventListener('mousemove', function(e) {
            if (!sliderTooltip) return;
            
            const rect = this.getBoundingClientRect();
            const percentage = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
            const time = (percentage / 100) * totalDuration;
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const timeString = minutes + ':' + String(seconds).padStart(2, '0');
            
            sliderTooltip.textContent = timeString;
            sliderTooltip.style.left = percentage + '%';
        });
        
        progressSlider.addEventListener('mouseenter', function() {
            if (sliderTooltip) {
                sliderTooltip.style.opacity = '1';
            }
        });
        
        progressSlider.addEventListener('mouseleave', function() {
            if (sliderTooltip && document.activeElement !== progressSlider) {
                sliderTooltip.style.opacity = '0';
            }
        });
        
        progressSlider.addEventListener('keydown', function(e) {
            const step = 1; // 1% step
            let newValue = parseFloat(this.value);
            
            if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
                e.preventDefault();
                newValue = Math.max(0, newValue - step);
                this.value = newValue;
                this.dispatchEvent(new Event('input'));
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
                e.preventDefault();
                newValue = Math.min(100, newValue + step);
                this.value = newValue;
                this.dispatchEvent(new Event('input'));
            } else if (e.key === 'Home') {
                e.preventDefault();
                this.value = 0;
                this.dispatchEvent(new Event('input'));
            } else if (e.key === 'End') {
                e.preventDefault();
                this.value = 100;
                this.dispatchEvent(new Event('input'));
            }
        });
        
        // Function to get pace value for a given level (duplicate - keeping for backward compatibility)
        function getPaceForLevelDuplicate(classPlanIntensity, userLevel = 5) {
            // Convert class plan pace intensity (0-6) to min/mi based on user's selected level (1-10)
            // Uses PaceTarget model pace ranges directly
            
            // Map class plan intensity (0-6) to intensity labels
            const intensityLabels = ['Recovery', 'Easy', 'Moderate', 'Challenging', 'Hard', 'Very Hard', 'Max'];
            const label = intensityLabels[classPlanIntensity] || 'Moderate';
            
            // Pace ranges from PaceTarget model for each user level (1-10)
            // Level 1 = slowest (highest min/mile), Level 10 = fastest (lowest min/mile)
            // Values are in decimal minutes per mile (e.g., 18.183 = 18:11 min/mile)
            const paceRangesByLevel = {
                1: {
                    "Recovery": [20.0, 60.0],      // 20:00 - 60:00 min/mile
                    "Easy": [18.183, 20.0],         // 18:11 - 20:00 min/mile
                    "Moderate": [16.667, 18.183],   // 16:40 - 18:11 min/mile
                    "Challenging": [15.0, 16.667],  // 15:00 - 16:40 min/mile
                    "Hard": [13.633, 15.0],         // 13:38 - 15:00 min/mile
                    "Very Hard": [12.25, 13.633],   // 12:15 - 13:38 min/mile
                    "Max": [4.8, 12.25]             // 4:48 - 12:15 min/mile
                },
                2: {
                    "Recovery": [18.75, 60.0],      // 18:45 - 60:00 min/mile
                    "Easy": [16.667, 18.75],        // 16:40 - 18:45 min/mile
                    "Moderate": [15.383, 16.667],   // 15:23 - 16:40 min/mile
                    "Challenging": [13.95, 15.383], // 13:57 - 15:23 min/mile
                    "Hard": [12.767, 13.95],        // 12:46 - 13:57 min/mile
                    "Very Hard": [11.533, 12.767],  // 11:32 - 12:46 min/mile
                    "Max": [4.8, 11.533]            // 4:48 - 11:32 min/mile
                },
                3: {
                    "Recovery": [17.133, 60.0],    // 17:08 - 60:00 min/mile
                    "Easy": [15.383, 17.133],       // 15:23 - 17:08 min/mile
                    "Moderate": [14.283, 15.383],   // 14:17 - 15:23 min/mile
                    "Challenging": [13.05, 14.283], // 13:03 - 14:17 min/mile
                    "Hard": [11.767, 13.05],        // 11:46 - 13:03 min/mile
                    "Very Hard": [10.717, 11.767],   // 10:43 - 11:46 min/mile
                    "Max": [4.8, 10.717]            // 4:48 - 10:43 min/mile
                },
                4: {
                    "Recovery": [16.217, 60.0],     // 16:13 - 60:00 min/mile
                    "Easy": [15.217, 16.217],       // 15:13 - 16:13 min/mile
                    "Moderate": [13.333, 15.217],   // 13:20 - 15:13 min/mile
                    "Challenging": [12.0, 13.333],  // 12:00 - 13:20 min/mile
                    "Hard": [11.117, 12.0],         // 11:07 - 12:00 min/mile
                    "Very Hard": [9.833, 11.117],   // 9:50 - 11:07 min/mile
                    "Max": [4.8, 9.833]             // 4:48 - 9:50 min/mile
                },
                5: {
                    "Recovery": [15.217, 60.0],     // 15:13 - 60:00 min/mile
                    "Easy": [13.333, 15.217],       // 13:20 - 15:13 min/mile
                    "Moderate": [12.25, 13.333],    // 12:15 - 13:20 min/mile
                    "Challenging": [11.117, 12.25], // 11:07 - 12:15 min/mile
                    "Hard": [10.0, 11.117],         // 10:00 - 11:07 min/mile
                    "Very Hard": [9.083, 10.0],     // 9:05 - 10:00 min/mile
                    "Max": [4.8, 9.083]             // 4:48 - 9:05 min/mile
                },
                6: {
                    "Recovery": [13.333, 60.0],        // 13:20 - 60:00 min/mile
                    "Easy": [12.25, 13.333],        // 12:15 - 13:20 min/mile
                    "Moderate": [11.117, 12.25],    // 11:07 - 12:15 min/mile
                    "Challenging": [10.0, 11.117],  // 10:00 - 11:07 min/mile
                    "Hard": [9.083, 10.0],          // 9:05 - 10:00 min/mile
                    "Very Hard": [8.217, 9.083],    // 8:13 - 9:05 min/mile
                    "Max": [4.8, 8.217]             // 4:48 - 8:13 min/mile
                },
                7: {
                    "Recovery": [12.0, 60.0],       // 12:00 - 60:00 min/mile
                    "Easy": [10.9, 12.0],           // 10:54 - 12:00 min/mile
                    "Moderate": [10.0, 10.9],       // 10:00 - 10:54 min/mile
                    "Challenging": [8.95, 10.0],    // 8:57 - 10:00 min/mile
                    "Hard": [8.217, 8.95],          // 8:13 - 8:57 min/mile
                    "Very Hard": [7.4, 8.217],      // 7:24 - 8:13 min/mile
                    "Max": [4.8, 7.4]               // 4:48 - 7:24 min/mile
                },
                8: {
                    "Recovery": [10.5, 60.0],       // 10:30 - 60:00 min/mile
                    "Easy": [9.683, 10.5],          // 9:41 - 10:30 min/mile
                    "Moderate": [8.817, 9.683],     // 8:49 - 9:41 min/mile
                    "Challenging": [8.0, 8.817],    // 8:00 - 8:49 min/mile
                    "Hard": [7.317, 8.0],           // 7:19 - 8:00 min/mile
                    "Very Hard": [6.583, 7.317],    // 6:35 - 7:19 min/mile
                    "Max": [4.8, 6.583]             // 4:48 - 6:35 min/mile
                },
                9: {
                    "Recovery": [9.217, 60.0],      // 9:13 - 60:00 min/mile
                    "Easy": [8.333, 9.217],         // 8:20 - 9:13 min/mile
                    "Moderate": [7.7, 8.333],       // 7:42 - 8:20 min/mile
                    "Challenging": [6.983, 7.7],    // 6:59 - 7:42 min/mile
                    "Hard": [6.383, 6.983],         // 6:23 - 6:59 min/mile
                    "Very Hard": [5.767, 6.383],   // 5:46 - 6:23 min/mile
                    "Max": [4.8, 5.767]             // 4:48 - 5:46 min/mile
                },
                10: {
                    "Recovery": [7.9, 60.0],        // 7:54 - 60:00 min/mile
                    "Easy": [7.15, 7.9],           // 7:09 - 7:54 min/mile
                    "Moderate": [6.667, 7.15],      // 6:40 - 7:09 min/mile
                    "Challenging": [6.0, 6.667],    // 6:00 - 6:40 min/mile
                    "Hard": [5.5, 6.0],            // 5:30 - 6:00 min/mile
                    "Very Hard": [4.917, 5.5],      // 4:55 - 5:30 min/mile
                    "Max": [4.8, 4.917]             // 4:48 - 4:55 min/mile
                }
            };
            
            // Clamp user level to valid range
            const clampedLevel = Math.max(1, Math.min(10, userLevel));
            const levelRanges = paceRangesByLevel[clampedLevel] || paceRangesByLevel[5];
            
            // Get the range for the current intensity
            const range = levelRanges[label] || levelRanges['Moderate'];
            const [minPace, maxPace] = range;
            
            // Use middle of the range
            const pace = (minPace + maxPace) / 2;
            const minutes = Math.floor(pace);
            const seconds = Math.round((pace - minutes) * 60);
            
            return {
                pace: `${minutes}:${seconds.toString().padStart(2, '0')} min/mi`,
                label: label,
                classPlanIntensity: classPlanIntensity
            };
        }

        paceLevelSelect.addEventListener('change', function() {
            // Update the target display based on user's selected level
            const selectedLevel = parseInt(this.value);
            console.log('User selected level:', selectedLevel);
            
            // Update current target display with new pace level
            const currentTarget = getCurrentTarget(chartCurrentTime);
            if (currentTarget !== null && currentTarget !== undefined) {
                const paceInfo = getPaceForLevel(currentTarget, selectedLevel);
                currentTargetEl.textContent = `${paceInfo.pace} @ ${paceInfo.label}`;
            }
            
            // Update fullscreen target display if in fullscreen
            const fullscreenCurrentTarget = document.getElementById('fullscreen-current-target');
            if (fullscreenCurrentTarget) {
                const fullscreenTarget = getCurrentTarget(chartCurrentTime);
                if (fullscreenTarget !== null && fullscreenTarget !== undefined) {
                    const paceInfo = getPaceForLevel(fullscreenTarget, selectedLevel);
                    fullscreenCurrentTarget.textContent = `${paceInfo.pace} @ ${paceInfo.label}`;
                }
            }
            
            // Force chart update to refresh tooltips with new pace level
            if (chart) {
                chart.update('none');
            }
        });
        
        // Toggle target line button
        const toggleTargetLineBtn = document.getElementById('toggle-target-line');
        if (toggleTargetLineBtn) {
            // Check if target line dataset exists
            const hasTargetLine = chart && chart.data.datasets.some(ds => ds.label === 'Target');
            
            if (hasTargetLine) {
                // Initialize button state
                showTargetLine = true;
                toggleTargetLineBtn.textContent = 'Hide Target';
                
                toggleTargetLineBtn.addEventListener('click', function() {
                    showTargetLine = !showTargetLine;
                    
                    // Update target line dataset visibility
                    if (chart) {
                        const targetDataset = chart.data.datasets.find(ds => ds.label === 'Target');
                        if (targetDataset) {
                            targetDataset.hidden = !showTargetLine;
                            chart.update('none');
                            console.log('Target line toggled. Visible:', showTargetLine);
                        } else {
                            console.warn('Target dataset not found in chart');
                        }
                    }
                    
                    // Update button text
                    this.textContent = showTargetLine ? 'Hide Target' : 'Show Target';
                });
            } else {
                // Hide button if no target line dataset
                toggleTargetLineBtn.style.display = 'none';
                console.log('No target line dataset found, hiding toggle button');
            }
        }
        
        // Save chart functionality
        const saveChartBtn = document.getElementById('save-chart');
        if (saveChartBtn) {
            saveChartBtn.addEventListener('click', function() {
                if (chart) {
                    const url = chart.toBase64Image();
                    const link = document.createElement('a');
                    link.download = 'pace-target-chart.png';
                    link.href = url;
                    link.click();
                }
            });
        }
        
        // Zone colors toggle
        const toggleZoneColors = document.getElementById('toggle-zone-colors');
        if (toggleZoneColors) {
            toggleZoneColors.addEventListener('change', function() {
                showZoneColors = this.checked;
                // Zone colors are handled by the bandPlugin, so we just need to update the chart
                if (chart) {
                    chart.update('none');
                }
            });
        }
        
        // Function to get current class plan intensity from chart data
        function getCurrentClassPlanIntensity() {
            // Get the current intensity from the chart data at the current time
            const currentTarget = getCurrentTarget(chartCurrentTime);
            return currentTarget || 2; // Default to Moderate if not found
        }
        
        // Set initial target based on class plan data
        if (chartData.type === 'pace_target' && chartData.segments && chartData.segments.length > 0) {
            // Get the first segment's pace intensity (class plan)
            const firstSegment = chartData.segments[0];
            const classPlanIntensity = firstSegment.zone || firstSegment.pace_level || 0;
            const userLevel = parseInt(paceLevelSelect.value) || 5;
            
            // Convert to min/mi based on user's level
            const paceInfo = getPaceForLevel(classPlanIntensity, userLevel);
            currentTargetEl.textContent = `${paceInfo.pace} @ ${paceInfo.label}`;
            
            console.log('Initial target set:', {
                classPlanIntensity,
                userLevel,
                paceInfo
            });
            
            // Debug: Check final segments
            console.log('All segments:', chartData.segments);
            const lastSegment = chartData.segments[chartData.segments.length - 1];
            console.log('Last segment:', lastSegment);
            console.log('Total duration from chart data:', chartData.total_duration);
        }
        
        // Initialize segment tracking
        if (chartData && chartData.segments && chartData.segments.length > 0) {
            lastSegmentIndex = getSegmentIndex(0);
        }
        
        // Initialize audio on user interaction (required by browsers)
        document.addEventListener('click', function() {
            initAudio();
        }, { once: true });
        
        // Fullscreen functionality
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const fullscreenOverlay = document.getElementById('fullscreen-overlay');
        const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
        let fullscreenChart = null;
        
        function enterFullscreen() {
            if (!fullscreenOverlay) return;
            
            fullscreenOverlay.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Sync values from main controls
            const fullscreenPaceLevelSelect = document.getElementById('fullscreen-pace-level-select');
            const fullscreenShowProgress = document.getElementById('fullscreen-show-progress');
            const fullscreenSoundToggle = document.getElementById('fullscreen-sound-toggle');
            
            if (fullscreenPaceLevelSelect) fullscreenPaceLevelSelect.value = paceLevelSelect.value;
            if (fullscreenShowProgress) fullscreenShowProgress.checked = document.getElementById('show-progress')?.checked ?? true;
            if (fullscreenSoundToggle) fullscreenSoundToggle.checked = document.getElementById('sound-toggle')?.checked ?? true;
            
            // Create fullscreen chart
            setTimeout(() => {
                createFullscreenChart();
            }, 100);
        }
        
        function exitFullscreen() {
            if (!fullscreenOverlay) return;
            
            fullscreenOverlay.style.display = 'none';
            document.body.style.overflow = '';
            
            // Destroy fullscreen chart
            if (fullscreenChart) {
                fullscreenChart.destroy();
                fullscreenChart = null;
            }
            
            // Sync values back to main controls
            const fullscreenPaceLevelSelect = document.getElementById('fullscreen-pace-level-select');
            const fullscreenShowProgress = document.getElementById('fullscreen-show-progress');
            const fullscreenSoundToggle = document.getElementById('fullscreen-sound-toggle');
            
            if (fullscreenPaceLevelSelect && paceLevelSelect) paceLevelSelect.value = fullscreenPaceLevelSelect.value;
            if (fullscreenShowProgress) {
                const showProgressCheckbox = document.getElementById('show-progress');
                if (showProgressCheckbox) showProgressCheckbox.checked = fullscreenShowProgress.checked;
            }
            if (fullscreenSoundToggle) {
                const soundToggle = document.getElementById('sound-toggle');
                if (soundToggle) soundToggle.checked = fullscreenSoundToggle.checked;
            }
        }
        
        function createFullscreenChart() {
            const fullscreenCtx = document.getElementById('fullscreen-class-plan-chart');
            if (!fullscreenCtx || fullscreenChart) return;
            
            // Get the chart configuration from the main chart
            if (!chart) {
                console.warn('Main chart not initialized yet');
                return;
            }
            
            // Rebuild chart config for fullscreen (same as main chart)
            const fullscreenChartConfig = {
                ...chartConfig,
                options: {
                    ...chartConfig.options,
                    maintainAspectRatio: false,
                    responsive: true
                }
            };
            
            // Create the fullscreen chart
            fullscreenChart = new Chart(fullscreenCtx, fullscreenChartConfig);
            
            // Sync fullscreen chart with main chart
            const fullscreenProgressSlider = document.getElementById('fullscreen-progress-slider');
            const fullscreenPlayPauseBtn = document.getElementById('fullscreen-play-pause-btn');
            const fullscreenPaceLevelSelect = document.getElementById('fullscreen-pace-level-select');
            const fullscreenShowProgress = document.getElementById('fullscreen-show-progress');
            const fullscreenSoundToggle = document.getElementById('fullscreen-sound-toggle');
            
            // Sync play/pause
            if (fullscreenPlayPauseBtn) {
                fullscreenPlayPauseBtn.addEventListener('click', function() {
                    if (isPlaying) {
                        pause();
                    } else {
                        play();
                    }
                    updateFullscreenPlayButton();
                });
            }
            
            // Sync pace level select
            if (fullscreenPaceLevelSelect) {
                fullscreenPaceLevelSelect.addEventListener('change', function() {
                    paceLevelSelect.value = this.value;
                    // Trigger the pace level change event to update tooltips
                    paceLevelSelect.dispatchEvent(new Event('change'));
                });
            }
            
            // Sync show progress checkbox
            if (fullscreenShowProgress) {
                fullscreenShowProgress.addEventListener('change', function() {
                    const showProgressCheckbox = document.getElementById('show-progress');
                    if (showProgressCheckbox) showProgressCheckbox.checked = this.checked;
                    updateProgress();
                });
            }
            
            // Sync sound toggle
            if (fullscreenSoundToggle) {
                fullscreenSoundToggle.addEventListener('change', function() {
                    const soundToggle = document.getElementById('sound-toggle');
                    if (soundToggle) soundToggle.checked = this.checked;
                });
            }
            
            // Sync slider
            if (fullscreenProgressSlider) {
                fullscreenProgressSlider.addEventListener('input', function() {
                    progressSlider.value = this.value;
                    progressSlider.dispatchEvent(new Event('input'));
                });
            }
            
            // Update fullscreen display
            updateFullscreenDisplay();
        }
        
        function updateFullscreenDisplay() {
            if (!fullscreenOverlay || fullscreenOverlay.style.display === 'none') return;
            
            const fullscreenTimeLeft = document.getElementById('fullscreen-time-left');
            const fullscreenIntervalTime = document.getElementById('fullscreen-interval-time');
            const fullscreenCurrentTarget = document.getElementById('fullscreen-current-target');
            const fullscreenProgressSlider = document.getElementById('fullscreen-progress-slider');
            const fullscreenSliderCurrentTime = document.getElementById('fullscreen-slider-current-time');
            
            if (fullscreenTimeLeft) {
                const timeLeft = Math.max(0, totalDuration - chartCurrentTime);
                const minutesLeft = Math.floor(timeLeft / 60);
                const secondsLeft = Math.floor(timeLeft % 60);
                fullscreenTimeLeft.textContent = minutesLeft + ':' + String(secondsLeft).padStart(2, '0');
            }
            
            if (fullscreenIntervalTime) {
                const currentSegment = getCurrentSegment(chartCurrentTime);
                const showProgressUp = document.getElementById('fullscreen-show-progress')?.checked ?? true;
                
                if (currentSegment) {
                    if (showProgressUp) {
                        const timeIntoInterval = chartCurrentTime - currentSegment.startTime;
                        const intervalMinutes = Math.floor(timeIntoInterval / 60);
                        const intervalSeconds = Math.floor(timeIntoInterval % 60);
                        fullscreenIntervalTime.textContent = intervalMinutes + ':' + String(intervalSeconds).padStart(2, '0');
                    } else {
                        const timeRemaining = currentSegment.endTime - chartCurrentTime;
                        const intervalMinutes = Math.floor(Math.max(0, timeRemaining) / 60);
                        const intervalSeconds = Math.floor(Math.max(0, timeRemaining) % 60);
                        fullscreenIntervalTime.textContent = intervalMinutes + ':' + String(intervalSeconds).padStart(2, '0');
                    }
                } else {
                    fullscreenIntervalTime.textContent = '00:00';
                }
            }
            
            if (fullscreenCurrentTarget) {
                const currentTarget = getCurrentTarget(chartCurrentTime);
                if (currentTarget !== null && currentTarget !== undefined) {
                    if (chartData.type === 'pace_target') {
                        const userLevel = parseInt(document.getElementById('fullscreen-pace-level-select')?.value || paceLevelSelect.value) || 5;
                        const paceInfo = getPaceForLevel(currentTarget, userLevel);
                        fullscreenCurrentTarget.textContent = `${paceInfo.pace} @ ${paceInfo.label}`;
                    } else {
                        const ftp = parseInt(ftpInput?.value || 250) || 250;
                        const targetOutput = Math.round(ftp * getZonePercentage(currentTarget));
                        fullscreenCurrentTarget.textContent = String(targetOutput) + ' @ Zone ' + currentTarget;
                    }
                }
            }
            
            if (fullscreenProgressSlider) {
                const progress = (chartCurrentTime / totalDuration) * 100;
                fullscreenProgressSlider.value = progress;
                
                if (fullscreenSliderCurrentTime) {
                    const minutes = Math.floor(chartCurrentTime / 60);
                    const seconds = Math.floor(chartCurrentTime % 60);
                    fullscreenSliderCurrentTime.textContent = minutes + ':' + String(seconds).padStart(2, '0');
                }
            }
            
            if (fullscreenChart) {
                fullscreenChart.options.plugins.progressLine.currentTime = chartCurrentTime;
                fullscreenChart.update('none');
            }
        }
        
        function updateFullscreenPlayButton() {
            const fullscreenPlayPauseBtn = document.getElementById('fullscreen-play-pause-btn');
            if (fullscreenPlayPauseBtn) {
                fullscreenPlayPauseBtn.textContent = isPlaying ? '⏸' : '▶';
                fullscreenPlayPauseBtn.classList.toggle('paused', isPlaying);
            }
        }
        
        // Event listeners for fullscreen
        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', enterFullscreen);
        }
        
        if (exitFullscreenBtn) {
            exitFullscreenBtn.addEventListener('click', exitFullscreen);
        }
        
        // Close fullscreen on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && fullscreenOverlay && fullscreenOverlay.style.display !== 'none') {
                exitFullscreen();
            }
        });
        
        // Add show progress checkbox listener
        const showProgressCheckbox = document.getElementById('show-progress');
        if (showProgressCheckbox) {
            showProgressCheckbox.addEventListener('change', function() {
                updateProgress();
            });
        }
        
        // Initial setup
        updateProgress();
        
        // Music timeline overlay (matching workout_detail)
        if (playlistData && playlistData.length > 0) {
            const musicTimelineEl = document.getElementById('musicTimeline');
            const showMusicCheckbox = document.getElementById('showMusicTimeline');
            
            function renderMusicTimeline() {
                if (!musicTimelineEl || !showMusicCheckbox) return;
                
                if (!showMusicCheckbox.checked) {
                    musicTimelineEl.classList.add('hidden');
                    return;
                }
                
                musicTimelineEl.classList.remove('hidden');
                musicTimelineEl.innerHTML = '';
                
                // Get max time from chart or ride duration
                const maxTime = totalDuration || {{ ride.duration_seconds|default:1800 }};
                const timelineWidth = musicTimelineEl.offsetWidth || 800;
                
                // Color palette for different songs (matching workout_detail)
                const songColors = [
                    'rgba(91, 124, 250, 0.4)',   // Blue
                    'rgba(34, 197, 94, 0.4)',    // Green
                    'rgba(234, 179, 8, 0.4)',    // Yellow
                    'rgba(239, 68, 68, 0.4)',    // Red
                    'rgba(168, 85, 247, 0.4)',   // Purple
                    'rgba(236, 72, 153, 0.4)',   // Pink
                    'rgba(20, 184, 166, 0.4)',   // Teal
                    'rgba(251, 146, 60, 0.4)',   // Orange
                ];
                
                playlistData.forEach((song, idx) => {
                    const startTime = song.start_time || 0;
                    const duration = song.duration || 180;
                    
                    // Calculate percentages based on max time (align with chart's time axis)
                    const startPercent = maxTime > 0 ? (startTime / maxTime) * 100 : 0;
                    const widthPercent = maxTime > 0 ? (duration / maxTime) * 100 : 0;
                    
                    // Ensure we don't go beyond 100%
                    const actualStartPercent = Math.max(0, Math.min(startPercent, 100));
                    const actualWidthPercent = Math.max(0, Math.min(widthPercent, 100 - actualStartPercent));
                    
                    // Skip if segment is too small or outside bounds
                    if (actualWidthPercent < 0.5 || actualStartPercent >= 100) {
                        return;
                    }
                    
                    const segment = document.createElement('div');
                    const color = songColors[idx % songColors.length];
                    const artistName = song.artists && song.artists.length > 0 ? song.artists[0] : '';
                    
                    segment.style.cssText = `
                        position: absolute;
                        left: ${actualStartPercent}%;
                        width: ${actualWidthPercent}%;
                        height: 100%;
                        background: ${color};
                        border-right: 1px solid rgba(255,255,255,0.25);
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        align-items: flex-start;
                        padding: 2px 6px;
                        font-size: 10px;
                        line-height: 1.2;
                        color: rgba(255,255,255,0.95);
                        overflow: hidden;
                        cursor: pointer;
                        transition: opacity 0.2s, background 0.2s;
                        min-width: 60px;
                    `;
                    
                    segment.onmouseenter = () => {
                        segment.style.opacity = '0.85';
                        segment.style.background = color.replace('0.4', '0.6');
                    };
                    segment.onmouseleave = () => {
                        segment.style.opacity = '1';
                        segment.style.background = color;
                    };
                    
                    // Create title element (truncate if too long)
                    const titleEl = document.createElement('div');
                    titleEl.style.cssText = 'font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; font-size: 10px;';
                    titleEl.textContent = song.title || 'Unknown';
                    
                    // Create artist element (only if there's space)
                    if (artistName && actualWidthPercent > 5) {
                        const artistEl = document.createElement('div');
                        artistEl.style.cssText = 'font-size: 9px; opacity: 0.8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; margin-top: 1px;';
                        artistEl.textContent = artistName;
                        segment.appendChild(artistEl);
                    }
                    
                    segment.insertBefore(titleEl, segment.firstChild);
                    
                    // Tooltip with full info
                    const fullInfo = `${song.title}${artistName ? ' • ' + artistName : ''}`;
                    segment.title = fullInfo;
                    
                    musicTimelineEl.appendChild(segment);
                });
            }
            
            if (showMusicCheckbox) {
                showMusicCheckbox.addEventListener('change', renderMusicTimeline);
                // Initial render after a short delay to ensure chart is rendered
                setTimeout(renderMusicTimeline, 200);
            }
        }
    })();
});
</script>

<!-- Workout Player CSS -->
<link rel="stylesheet" href="{% static 'css/workout-player.css' %}" />
